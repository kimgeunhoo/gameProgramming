/*
	작성일: 2025-02-20
	작성자: 김근호
	주제: 데이터 표현 방식
*/

/*
	2가지의 타입 : 정수, 실수 + 문자(숫자 아스키코드)
	int, char, short, long, longlong - 정수
	float, double, decimal - 실수

	(사람 - 사람) (컴퓨터 - 사람) int 이해
	int 변수 이름; 변수 이름 녀석이 정수형태의 값을 받을 수 있다. + 데이터 저장 크기를 지정
*/

/*
	정수를 표현하는 방법
	- 표현하는 키워드가 많다.
	- 이유 : 최선의 메모리를 사용하기 위해서
	- 컴퓨터가 정보를 읽는 최소 단위 : 바이트 = 8비트
	- 비트 ㅁ(0,1)

	char(1), short(2), int(4) 컴파일러에 따라 다를 수 있음
	10진수 2진수
		0000 0000	2^8
	16 = 0000 1000
	127 = 0011 1111

	int attackpower; 00000000 00000000 00000000 00000000;
	char ch1;									00000000;

*/

/*
	뺄셈 : 덧셈 A - B    a + ( -B )
	정수 : 음수를 표현하는 방법
	MSB : Most Signmant Bit
	데이터 표현 방식에서 가장 왼쪽 끝 비트에 할당한다.

	5 양수  0 0000101
	-5 음수 1 0000101

	5 + (-5) = 0

		다른 방법(보수법) 1 1111010 + 1
		0 0000101
		1 1111011
	  1 0 0000000
		양수를 비트로 표현 후 모든 비트 반전 + 1

	메모리 측면.
	unsigned int
*/

/*
	컴퓨터는 데이터 타입 (형)이 다르면 문제가 생길수 있다 (오버플로우)
	문제가 생겻을때 어떻게 해결하나?
	어떤 방식으로 문제를 해결하나?
*/

/*
	실수를 표현하는 방식

	2바이트			00000000 00000000
	8: 8 (절반은 정수, 절반은 실수)
	00000101 00000101 -> 5.5

	5.4955 // 표연하고자 한ㄴ 수가 얼마 차이 나지 않는다. 실수로 표연하는 비트의 수가 너무 적다
	실수를 표현할 수 있는 범위가 너무 적다

	부동소수점 방식 : float 둥둥 떠다닌다

	125.234091

	(정수)	*	정규화된 식^(지수)
	어떤 수를 제곱, 1;
	33^0 = 1
	0

	1.25234091 * 10^2

	수를 0 < < 10 사이의 수를 표현한다

	0.2334

	부동소수점의 오차가 발생한다
	1 = 1.0 컴퓨터에선 다름



*/

/*
	int attackpower = 10 + 1 * 0.3;

	리터럴 상수
	int, double		- int 형 정의, double 형 정의
	1 * 0.3;		0.3
	int 정의 =>		0
	double 정의 =>  0.3
	반드시 손실이 발생.	-> 소숫점 아래는 날라간다
	이유 -> double	11 + 0.3
*/

/*
	데이터형 -> 스스로 형태를 바꾸고 있다.
	형 변환
	- 자동 : 묵시적 변환
	- 수동 : 명시적 변환

*/

#include <stdio.h>

int main() 
{
	int attackpower = 10 + 1 * 0.3; // 10.3
	double attackpower2 = 10 + 1 * 0.3; // 10.3

	printf("값 : %d\n", attackpower); // 정수 방식
	printf("값 : %.1lf\n", attackpower2); // 실수 방식

	printf("정수의 표현 방식 실습\n");

	char num1 = 129; // 0000 0000
					 // 0111 1111 127
					 // 1000 0001
	int num2 = 129;		// ( ) ( ) ( ) 1000 0001
	char num3 = num2;   //
	printf("값 : %d\n", num1);
	printf("값 : %d\n", num3); //

	printf("실수의 표현 방식 실습\n");

	float num4 = 0.1;

	for (int i = 0; i < 1000; i++) {
		num4 += 0.1;
	}
	printf("값 : %f\n", num4);


}